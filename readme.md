# ClockHelper v0.2.0

ClockHelper is a utility to facilitate clock management on STM32 microcontrollers.
### Note: 
ClockHelper is in the early stages of development, configurations may be incorrect/incomplete. In case of errors, feel free to open an issue.

- state after rework: this project is under rework and is currently in the second phase of development. In this phase the focus is to identify problems in code generation, such as useless flags, incorrect configurations, invalid or unreachable expressions, errors in clock values and configuration after data processing, typos and more. The idea is to catalog as many problems as possible and identify which problems should be fixed by the code generator before starting the manual patching stage. 



## CLI tool
### CLI notice: The CLI is currently obsolete, but will be updated as soon as the project reaches a more stable state

clock helper comes with a utility to transcribe configurations generated by CubeMX (.ioc files) into configurations for embedded Zig projects

to create an executable of this tool: `zig build clock_helper --release=safe`

usage: `clock_helper -i <ioc file> -o <out file>`

## usage

To use it, it's very simple:

Choose a controller from the [list](src/lib.zig):

```zig
const ClockHelper = @import("ClockHelper");

const STM32F103x = ClockHelper.@"STM32F103C(8-B)Tx";
```

Create a clock using the settings you want to use:

```zig
const config = STM32F103x.Config{
    .SYSCLKSource = .RCC_SYSCLKSOURCE_PLLCLK,
    //.PLLSource = .RCC_PLLSOURCE_HSI_DIV2, USB force Pllsource to be HSE
    .PLLMUL = .RCC_PLL_MUL6,
    .APB1CLKDivider = .RCC_HCLK_DIV2,
    .flags = .{ .USBUsed_ForRCC = true, .HSEOscillator = true },
};

const out = STM32F103x.get_clocks(config) catch unreachable;
const Clock = out.clock;
```
And that's it â€” ClockHelper will provide the clock value for each peripheral for this configuration. It also analyzes and builds all RCC configurations, returning comprehensive error messages if any errors occur.

```zig
const std = @import("std");
const ClockHelper = @import("ClockHelper");

const STM32F103x = ClockHelper.@"STM32F103C(8-B)Tx";

const config = STM32F103x.Config{
    .SYSCLKSource = .RCC_SYSCLKSOURCE_PLLCLK,
    //.PLLSource = .RCC_PLLSOURCE_HSI_DIV2, USB force Pllsource to be HSE
    .PLLMUL = .RCC_PLL_MUL6,
    .APB1CLKDivider = .RCC_HCLK_DIV2,
    .flags = .{ .USBUsed_ForRCC = true, .HSEOscillator = true },
};

const out = STM32F103x.get_clocks(config) catch unreachable;
const Clock = out.clock;

pub fn main() !void {
    @compileLog(std.fmt.comptimePrint(
        \\Corrent OutClocks:
        \\SysClock: {d}Mhz
        \\AHB Clock: {d}Mhz
        \\APB1 Clock: {d}Mhz
        \\TimAPB1: {d}Mhz
        \\APB2 Clock: {d}Mhz
        \\TimAPB2: {d}Mhz
        \\USB: {d}Mhz
        \\
    , .{
        (Clock.SysCLKOutput / 1_000_000),
        (Clock.AHBOutput / 1_000_000),
        (Clock.APB1Output / 1_000_000),
        (Clock.TimPrescOut1 / 1_000_000),
        (Clock.APB2Output / 1_000_000),
        (Clock.TimPrescOut2 / 1_000_000),
        (Clock.USBoutput / 1_000_000),
    }));
}

```




